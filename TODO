- type definitions/annotations/checking/inference
- polymorphism?
    - polymorphic types, monomorphic terms:
        (<*>) : >(a -> b) -> >a -> >b
        f = (<*>)                         => ambiguous type variable
        f = (<*>) : >(A -> B) -> >A -> >B => OK
    - HM polymorphism
- implicit Fix in recursive type definitions (arguments have to be the same):
    type StrG A = A * >(StrG A)
    => (StrG, TAbs "A" (Fix X. A * >X))
- :type
- optional curlies and semicolons (haskell-style layout)
- base types (integers, booleans, ...) and operations
- infix operators
- idiom brackets or !(notation) or something
- standard library (streams, ...)
- cons/destructor generation, pattern matching
- better user interaction with streams
- call-by-need?
- write documentation

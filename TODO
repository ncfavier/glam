- type definitions/annotations/checking/inference
- implicit Fix in recursive type definitions (arguments have to be the same):
    type StrG A = A * >(StrG A)
    => type StrG A = Fix X. A * >X
- optional curlies and semicolons (haskell-style layout)
- base types (integers, booleans, ...) and operations
- infix operators
- idiom brackets or something
- auto (un)box/next/prev? (type safety?)
- standard library (streams, ...)
- cons/destructor generation, pattern matching
- better user interaction with streams
- call-by-need?
- write documentation
